name: Deploy to AWS App Runner

on:
  push:
    branches: [ main ]

concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-central-1
  # Use the GitHub repo name for both the ECR repo and App Runner service name
  ECR_REPOSITORY: ${{ github.event.repository.name }}
  APP_RUNNER_SERVICE_NAME: ${{ github.event.repository.name }}

  # App-specific settings
  APP_PORT: "80"
  CPU: "0.25 vCPU"          # valid: "1 vCPU" | "2 vCPU"
  MEMORY: "0.5 GB"         # valid: "2 GB" | "3 GB" | "4 GB" | "8 GB"

  # REQUIRED: role that lets App Runner pull from your private ECR
  # Create once and paste here (or store in GitHub secret and reference as ${{ secrets... }})
  ECR_ACCESS_ROLE_ARN: arn:aws:iam::619575810103:role/AppRunnerECRAccessRole

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::619575810103:role/GitHubActionsDeployRole   # <-- change
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Ensure ECR repo exists (idempotent)
        run: |
          aws ecr describe-repositories --repository-names "$ECR_REPOSITORY" >/dev/null 2>&1 || \
          aws ecr create-repository \
            --repository-name "$ECR_REPOSITORY" \
            --image-scanning-configuration scanOnPush=true >/dev/null

      - name: Apply/refresh ECR lifecycle policy (keep images + cache)
        run: |
          cat > policy.json <<'JSON'
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep buildcache images for 3 days",
                "selection": { 
                  "tagStatus": "tagged", 
                  "tagPrefixList": ["buildcache"], 
                  "countType": "sinceImagePushed", 
                  "countUnit": "days", 
                  "countNumber": 3 
                },
                "action": { "type": "expire" }
              },
              {
                "rulePriority": 2,
                "description": "Keep last 10 images (any tag)",
                "selection": { 
                  "tagStatus": "any", 
                  "countType": "imageCountMoreThan", 
                  "countNumber": 10 
                },
                "action": { "type": "expire" }
              }
            ]
          }
          JSON
          aws ecr put-lifecycle-policy \
            --repository-name "$ECR_REPOSITORY" \
            --lifecycle-policy-text file://policy.json

      - name: Compute image tags
        id: meta
        run: |
          REGISTRY="${{ steps.ecr.outputs.registry }}"
          IMAGE_BASE="$REGISTRY/$ECR_REPOSITORY"
          SHA_TAG="${IMAGE_BASE}:${GITHUB_SHA}"
          LATEST_TAG="${IMAGE_BASE}:latest"
          echo "sha_tag=$SHA_TAG"   >> $GITHUB_OUTPUT
          echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # A) Build with Dockerfile if present
      - name: Build & push (Dockerfile)
        if: ${{ hashFiles('Dockerfile') != '' }}
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          platforms: linux/amd64
          tags: |
            ${{ steps.meta.outputs.sha_tag }}
            ${{ steps.meta.outputs.latest_tag }}
          cache-from: type=registry,ref=${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:buildcache
          cache-to: type=registry,ref=${{ steps.ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:buildcache,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      # B) Build with Buildpacks if no Dockerfile
      - name: Install pack (Buildpacks)
        uses: buildpacks/github-actions/setup-pack@v5.9.5

      - name: Build image with Buildpacks & push
        if: ${{ hashFiles('Dockerfile') == '' }}
        run: |
          BUILDER="paketobuildpacks/builder-jammy-base"
          pack build "${{ steps.meta.outputs.sha_tag }}" \
            --path . \
            --builder "$BUILDER" \
            --publish

      - name: Resolve or create App Runner service
        id: apprunner
        run: |
          set -euo pipefail

          # Try to find existing service ARN by name
          ARN=$(aws apprunner list-services \
            --query "ServiceSummaryList[?ServiceName=='${APP_RUNNER_SERVICE_NAME}'].ServiceArn | [0]" \
            --output text)

          if [ -n "$ARN" ] && [ "$ARN" != "None" ]; then
            echo "Service exists: $ARN"
            echo "service_arn=$ARN" >> $GITHUB_OUTPUT
          else
            echo "Service not found. Creating: ${APP_RUNNER_SERVICE_NAME}"
            NEW_ARN=$(aws apprunner create-service \
              --service-name "${APP_RUNNER_SERVICE_NAME}" \
              --source-configuration "ImageRepository={ImageIdentifier=${{ steps.meta.outputs.sha_tag }},ImageRepositoryType=ECR,ImageConfiguration={Port=${APP_PORT}}},AuthenticationConfiguration={AccessRoleArn=${ECR_ACCESS_ROLE_ARN}}" \
              --instance-configuration "Cpu=${CPU},Memory=${MEMORY}" \
              --health-check-configuration "Protocol=TCP,Interval=5,Timeout=2,HealthyThreshold=1,UnhealthyThreshold=5" \
              --query "Service.ServiceArn" \
              --output text)
            echo "Created service: $NEW_ARN"
            echo "service_arn=$NEW_ARN" >> $GITHUB_OUTPUT
            echo "SKIP_UPDATE=1" >> $GITHUB_ENV
          fi

      - name: Update App Runner to new image (if already existed)
        if: env.SKIP_UPDATE != '1'
        run: |
          aws apprunner update-service \
            --service-arn "${{ steps.apprunner.outputs.service_arn }}" \
            --source-configuration "ImageRepository={ImageIdentifier=${{ steps.meta.outputs.sha_tag }},ImageRepositoryType=ECR,ImageConfiguration={Port=${APP_PORT}}}" \
            --instance-configuration "Cpu=${CPU},Memory=${MEMORY}"
          echo "Triggered deployment to App Runner."